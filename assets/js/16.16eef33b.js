(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{422:function(t,v,a){"use strict";a.r(v);var _=a(2),e=Object(_.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"title"}),v("p",[t._v("详解http的基础知识，通俗易懂。")]),t._v(" "),v("p",[t._v("转载："),v("a",{attrs:{href:"https://xiaolincoding.com/network/",target:"_blank",rel:"noopener noreferrer"}},[t._v("小林coding图解网络"),v("OutboundLink")],1)])]),v("h2",{attrs:{id:"基本概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),v("p",[t._v("HTTP 是超文本传输协议，也就是HyperText Transfer Protocol\n它可以拆成三个部分：")]),t._v(" "),v("ul",[v("li",[t._v("超文本")]),t._v(" "),v("li",[t._v("传输")]),t._v(" "),v("li",[t._v("协议")])]),t._v(" "),v("ol",[v("li",[t._v("[协议]")])]),t._v(" "),v("p",[t._v("HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("[传输]")])]),t._v(" "),v("p",[t._v("HTTP 协议是一个双向协议。")]),t._v(" "),v("p",[t._v("我们在上网冲浪时，浏览器是请求方 A，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。")]),t._v(" "),v("p",[t._v("针对传输，我们可以进一步理解了 HTTP。")]),t._v(" "),v("p",[t._v("HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。")]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("[超文本]")])]),t._v(" "),v("p",[t._v("HTTP 传输的内容是「超文本」。")]),t._v(" "),v("p",[t._v("我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。")]),t._v(" "),v("p",[t._v("再来理解「超文本」，它就是超越了普通文本的文本，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。")]),t._v(" "),v("p",[t._v("HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。")]),t._v(" "),v("p",[v("em",[t._v("HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。")])]),t._v(" "),v("h2",{attrs:{id:"http常见的状态码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http常见的状态码"}},[t._v("#")]),t._v(" HTTP常见的状态码")]),t._v(" "),v("p",[v("code",[t._v("1xx")]),t._v("状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。")]),t._v(" "),v("p",[v("code",[t._v("2xx")]),t._v(" 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。")]),t._v(" "),v("ul",[v("li",[t._v("[200 OK] 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。")]),t._v(" "),v("li",[t._v("[204 No Content]也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。")]),t._v(" "),v("li",[t._v("[206 Partial Content]是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。")])]),t._v(" "),v("p",[v("code",[t._v("3xx")]),t._v("类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。")]),t._v(" "),v("ul",[v("li",[t._v("「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。")]),t._v(" "),v("li",[t._v("「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。")])]),t._v(" "),v("p",[t._v("301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。")]),t._v(" "),v("ul",[v("li",[t._v("「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。")])]),t._v(" "),v("p",[v("code",[t._v("4xx")]),t._v(" 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。")]),t._v(" "),v("ul",[v("li",[t._v("「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。")]),t._v(" "),v("li",[t._v("「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。")]),t._v(" "),v("li",[t._v("「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。")])]),t._v(" "),v("p",[v("code",[t._v("5xx")]),t._v(" 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。")]),t._v(" "),v("ul",[v("li",[t._v("「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。")]),t._v(" "),v("li",[t._v("「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。")]),t._v(" "),v("li",[t._v("「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。")]),t._v(" "),v("li",[t._v("「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。")])]),t._v(" "),v("h2",{attrs:{id:"http常见字段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http常见字段"}},[t._v("#")]),t._v(" HTTP常见字段")]),t._v(" "),v("ul",[v("li",[t._v("Host字段")]),t._v(" "),v("li",[t._v("Content-Length 字段,代表数据长度")]),t._v(" "),v("li",[t._v("Connection 字段,长连接,HTTP/1.1默认是长连接，为兼容老版本的HTTP，需要指定"),v("code",[t._v("Connection: Keep-Alive")])]),t._v(" "),v("li",[t._v("Content-Type 字段,于服务器回应时，告诉客户端，本次数据是什么格式。\n"),v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/10-content-type%E5%AD%97%E6%AE%B5.png",alt:"avatar"}})])]),t._v(" "),v("div",{staticClass:"language-javascript extra-class"},[v("pre",{pre:!0,attrs:{class:"language-javascript"}},[v("code",[t._v("Content"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Type"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" text"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("html"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" Charset"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("utf"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v("\n")])])]),v("p",[t._v("客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。")]),t._v(" "),v("div",{staticClass:"language-javascript extra-class"},[v("pre",{pre:!0,attrs:{class:"language-javascript"}},[v("code",[v("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("Accept")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*    表示客户端声明自己可以接受任何格式的数据\n")])])])]),v("ul",[v("li",[t._v("Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式")])]),t._v(" "),v("div",{staticClass:"language-javascript extra-class"},[v("pre",{pre:!0,attrs:{class:"language-javascript"}},[v("code",[t._v("Content"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Encoding"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" gzip  "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。")]),t._v("\n")])])]),v("div",{staticClass:"language-javascript extra-class"},[v("pre",{pre:!0,attrs:{class:"language-javascript"}},[v("code",[t._v("Accept"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Encoding"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" gzip"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" deflate "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。")]),t._v("\n")])])]),v("h2",{attrs:{id:"get与post有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#get与post有什么区别"}},[t._v("#")]),t._v(" GET与POST有什么区别")]),t._v(" "),v("p",[t._v("根据 RFC 规范，"),v("strong",[t._v("GET 的语义是从服务器获取指定的资源")]),t._v("，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。")]),t._v(" "),v("p",[t._v("根据 RFC 规范，"),v("strong",[t._v("POST 的语义是根据请求负荷（报文body）对指定的资源做出处理")]),t._v("，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。")]),t._v(" "),v("h3",{attrs:{id:"get-和-post-方法都是安全和幂等的吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#get-和-post-方法都是安全和幂等的吗"}},[t._v("#")]),t._v(" GET 和 POST 方法都是安全和幂等的吗？")]),t._v(" "),v("ul",[v("li",[t._v("在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。")]),t._v(" "),v("li",[t._v("所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。")])]),t._v(" "),v("p",[t._v("如果从 RFC 规范定义的语义来看：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("GET 方法就是安全且幂等的")]),t._v("，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，"),v("strong",[t._v("可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签")]),t._v("。")]),t._v(" "),v("li",[v("strong",[t._v("POST")]),t._v(" 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，"),v("strong",[t._v("浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签")]),t._v("。")])]),t._v(" "),v("p",[t._v("但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：")]),t._v(" "),v("ul",[v("li",[t._v("可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。")]),t._v(" "),v("li",[t._v("可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。")])]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"title"}),v("p",[v("strong",[t._v("GET 请求可以带 body 吗？")])]),t._v(" "),v("p",[t._v("RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。")]),t._v(" "),v("p",[t._v("另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。")])]),v("h2",{attrs:{id:"http缓存技术"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http缓存技术"}},[t._v("#")]),t._v(" HTTP缓存技术")]),t._v(" "),v("p",[t._v("HTTP 缓存有两种实现方式，分别是"),v("strong",[t._v("强制缓存")]),t._v("和"),v("strong",[t._v("协商缓存")]),t._v("。")]),t._v(" "),v("h3",{attrs:{id:"强制缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[t._v("#")]),t._v(" 强制缓存")]),t._v(" "),v("p",[t._v("强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("Cache-Control")]),t._v(",是一个相对时间")]),t._v(" "),v("li",[v("code",[t._v("Expires")]),t._v(",是一个绝对时间")])]),t._v(" "),v("p",[t._v("如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，Cache-Control 的优先级高于 Expires")]),t._v(" "),v("p",[t._v("Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：")]),t._v(" "),v("ul",[v("li",[t._v("当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小")]),t._v(" "),v("li",[t._v("浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器")]),t._v(" "),v("li",[t._v("服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control")])]),t._v(" "),v("h3",{attrs:{id:"协商缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),v("p",[t._v("当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 304，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。")]),t._v(" "),v("ol",[v("li",[t._v("第一种：请求头部中的 "),v("code",[t._v("If-Modified-Since")]),t._v(" 字段与响应头部中的 "),v("code",[t._v("Last-Modified")]),t._v(" 字段实现，这两个字段的意思是：")])]),t._v(" "),v("ul",[v("li",[t._v("响应头部中的 "),v("code",[t._v("Last-Modified")]),t._v("：标示这个响应资源的最后修改时间；")]),t._v(" "),v("li",[t._v("请求头部中的 If-Modified-Since：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。")])]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("第二种：请求头部中的 If-None-Match 字段与响应头部中的 ETag 字段，这两个字段的意思是：")])]),t._v(" "),v("ul",[v("li",[t._v("响应头部中 Etag：唯一标识响应资源；")]),t._v(" "),v("li",[t._v("请求头部中的 If-None-Match：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。")])]),t._v(" "),v("p",[t._v("第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。")]),t._v(" "),v("p",[t._v("如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，这时 Etag 的优先级更高，也就是服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。")]),t._v(" "),v("p",[t._v("**为什么 ETag 的优先级更高？**这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：")]),t._v(" "),v("ol",[v("li",[t._v("在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；")]),t._v(" "),v("li",[t._v("可能有些文件是在秒级以内修改的，If-Modified-Since 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；")]),t._v(" "),v("li",[t._v("有些服务器不能精确获取文件的最后修改时间。")])]),t._v(" "),v("p",[t._v("注意，"),v("strong",[t._v("协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求")]),t._v("。")]),t._v(" "),v("p",[t._v("当使用 ETag 字段实现的协商缓存的过程：")]),t._v(" "),v("ul",[v("li",[t._v("当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；")]),t._v(" "),v("li",[t._v("当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：")])]),t._v(" "),v("ul",[v("li",[t._v("如果没有过期，则直接使用本地缓存")]),t._v(" "),v("li",[t._v("如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；")])]),t._v(" "),v("ul",[v("li",[t._v("服务器再次收到请求后，"),v("strong",[t._v("会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：")])])]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("如果值相等，则返回 304 Not Modified，不会返回资源")])]),t._v(" "),v("li",[t._v("如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识")])]),t._v(" "),v("ul",[v("li",[t._v("如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。")])])])}),[],!1,null,null,null);v.default=e.exports}}]);