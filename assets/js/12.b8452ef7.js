(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{424:function(t,e,a){"use strict";a.r(e);var s=a(2),o=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"title"}),e("p",[t._v("随着容器化技术盛行，Docker在前端领域也有着越来越广泛的应用；传统的前端部署方式需要我们将项目打包生成一系列的静态文件，然后上传到服务器，配置nginx文件；如果我们使用容器化部署，将部署操作都命令化，集中成一个脚本就可以完成原来复杂的部署过程。本文从Docker基础开始，来认识Docker的各种命令操作。")])]),e("h2",{attrs:{id:"docker简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker简介"}},[t._v("#")]),t._v(" Docker简介")]),t._v(" "),e("p",[t._v("从"),e("strong",[t._v("Docker")]),t._v("的logo我们也能看出，Docker的思想来自于集装箱；各个应用程序相当于不同的集装箱，每个应用程序有着不同的应用环境，比如python开发的应用需要服务器部署一套python的开发环境，nodejs开发的应用需要服务器部署nodejs的环境，不同环境之间有可能还会彼此冲突，Docker可以帮助我们隔离不同的环境。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://s1.ax1x.com/2023/02/16/pSHWvSf.jpg",alt:"docker"}})]),t._v(" "),e("p",[t._v("接触过虚拟机的同学就发问了，这不是虚拟机干的活么。是的，虚拟机可以很好的帮我们隔离各个环境，我们可以在windows上运行macos、ubuntu等虚拟机，也可以在macos上安装windows的虚拟机；不过传统的虚拟机技术是虚拟一整套硬件后，在其上运行完整的操作系统，在该系统上再运行所需应用进程，这样导致一台电脑只能运行数量较少的虚拟机。")]),t._v(" "),e("p",[t._v("但是Docker使用的容器技术比虚拟机更加的轻便和快捷。容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便"),e("br"),t._v("\n对比总结：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("特性")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("容器")]),t._v(" "),e("th",{staticStyle:{"text-align":"right"}},[t._v("虚拟机")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("启动")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("秒级")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[t._v("分钟级")])]),t._v(" "),e("tr",[e("td",[t._v("硬盘使用")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("一般为MB")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[t._v("一般为GB")])]),t._v(" "),e("tr",[e("td",[t._v("系统资源")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("0~5%")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[t._v("5~15%")])]),t._v(" "),e("tr",[e("td",[t._v("性能")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("接近原生")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[t._v("弱于原生")])]),t._v(" "),e("tr",[e("td",[t._v("系统支持量")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("单机支持上千个容器")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[t._v("一般几十个")])])])]),t._v(" "),e("h3",{attrs:{id:"docker优势"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker优势"}},[t._v("#")]),t._v(" "),e("strong",[t._v("Docker优势")])]),t._v(" "),e("p",[e("strong",[t._v("docker有以下优势：")])]),t._v(" "),e("ul",[e("li",[t._v("更高效的利用系统资源")]),t._v(" "),e("li",[t._v("更快速的启动时间")]),t._v(" "),e("li",[t._v("一致的运行环境")]),t._v(" "),e("li",[t._v("持续交付和部署")]),t._v(" "),e("li",[t._v("更轻松的迁移")]),t._v(" "),e("li",[t._v("更轻松的维护和扩展")])]),t._v(" "),e("p",[e("strong",[t._v("docker通常用于如下场景：")])]),t._v(" "),e("ul",[e("li",[t._v("web应用的自动化打包和发布")]),t._v(" "),e("li",[t._v("自动化测试和持续集成、发布")]),t._v(" "),e("li",[t._v("在服务器环境中部署和调整数据库或其他的后台应用")]),t._v(" "),e("li",[t._v("从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境")])]),t._v(" "),e("h3",{attrs:{id:"基本概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[t._v("#")]),t._v(" "),e("strong",[t._v("基本概念")])]),t._v(" "),e("ul",[e("li",[t._v("镜像（Image）")]),t._v(" "),e("li",[t._v("容器（Container）")]),t._v(" "),e("li",[t._v("仓库（Repository）")])]),t._v(" "),e("p",[t._v("首先我们来弄懂"),e("strong",[t._v("镜像")]),t._v("的概念，Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。")]),t._v(" "),e("p",[t._v("如果有装系统经验的童鞋，可以把Docker镜像理解为一个操作系统的镜像（ISO文件），它是一个固定的文件，从一个镜像中，我们可以装到很多电脑上，变成一个个的操作系统（相当于容器），每个系统都是相同的，不过可以选择定制化安装。")]),t._v(" "),e("p",[t._v("和系统镜像不同的是，Docker镜像并不是像ISO文件那样整体打包成一个文件的，而是设计成了分层存储的架构，它并不是由一个文件组成，而是由多层文件联合组成。构建镜像时，会一层层的构建，前面一层是后面一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。")]),t._v(" "),e("p",[t._v("其次是"),e("strong",[t._v("容器")]),t._v("的概念，从编程的角度看，镜像和容器的关系更像是类和实例的关系；从一个镜像可以启动一个或者多个容器；镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。")]),t._v(" "),e("p",[t._v("前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为"),e("strong",[t._v("容器存储层")]),t._v("。")]),t._v(" "),e("p",[t._v("容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://s1.ax1x.com/2023/02/16/pSHIvqO.png",alt:"容器存储层"}})]),t._v(" "),e("p",[t._v("因此容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层。")]),t._v(" "),e("p",[t._v("最后是**仓库（Repository）**的概念，我们构建一个镜像后，可以在本地运行，但是如果我们想要给网络上的其他用户使用，就要一个集中存储和分发镜像的服务器，仓库就是这样一个工具，有点类似Github。")]),t._v(" "),e("p",[t._v("镜像仓库Repository是同一类镜像的集合，包含了不同tag（标签）的Docker镜像，比如"),e("strong",[t._v("ubuntu")]),t._v("是仓库的名称，它里面有不同的tag，比如"),e("strong",[t._v("16.04、18.04")]),t._v("，我们从镜像仓库中来获取镜像时可以通过<仓库名>:<标签>的格式来指定具体版本的镜像，比如"),e("strong",[t._v("ubuntu18.04")]),t._v("；如果忽略标签，用"),e("strong",[t._v("latest")]),t._v("作为默认标签。")]),t._v(" "),e("h2",{attrs:{id:"镜像"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#镜像"}},[t._v("#")]),t._v(" 镜像")]),t._v(" "),e("p",[t._v("镜像是Docker的三个基本组件之一；运行容器需要本地有相应的镜像，如果没有会从远程仓库下载；那么我们来看下如何操作镜像。"),e("br")]),t._v(" "),e("h3",{attrs:{id:"查找镜像"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查找镜像"}},[t._v("#")]),t._v(" "),e("strong",[t._v("查找镜像")])]),t._v(" "),e("p",[t._v("我们可以从"),e("code",[t._v("Docker Hub")]),t._v("来搜索镜像(请在服务器环境下操作)")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("docker search ubuntu\n")])])]),e("p",[t._v("查找结果:"),e("br"),t._v(" "),e("img",{attrs:{src:"https://s1.ax1x.com/2023/02/16/pSH7RxI.png",alt:"docker"}})]),t._v(" "),e("p",[t._v("查找的列表中包含了以下几个字段：")]),t._v(" "),e("ul",[e("li",[t._v("NAME：镜像仓库源的名称")]),t._v(" "),e("li",[t._v("DESCRIPTION: 镜像的描述")]),t._v(" "),e("li",[t._v("STARS：类似Github里面的star")]),t._v(" "),e("li",[t._v("OFFICIAL：是否docker官方发布")]),t._v(" "),e("li",[t._v("AUTOMATED：自动构建")])]),t._v(" "),e("h3",{attrs:{id:"获取镜像"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#获取镜像"}},[t._v("#")]),t._v(" "),e("strong",[t._v("获取镜像")])]),t._v(" "),e("p",[t._v("我们要获取镜像，可以通过"),e("code",[t._v("docker pull")]),t._v("命令，它的格式如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("docker pull <repository>:<tag>\n")])])]),e("p",[t._v("还是以ubuntu为例：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("[root@localhost dockerfile]# docker pull ubuntu:16.04\n16.04: Pulling from library/ubuntu\n58690f9b18fc: Pull complete \nb51569e7c507: Pull complete \nda8ef40b9eca: Pull complete \nfb15d46c38dc: Pull complete \nDigest: sha256:0f71fa8d4d2d4292c3c617fda2b36f6dabe5c8b6e34c3dc5b0d17d4e704bd39c\nStatus: Downloaded newer image for ubuntu:16.04\ndocker.io/library/ubuntu:16.04\n")])])]),e("p",[t._v("我们看到最后一行docker.io显示这是从官方仓库拉取的。")]),t._v(" "),e("p",[t._v("从下载过程我们可以看出我们上面说的分层存储的概念，即镜像是由多层存储构成；下载也是一层层的去下载，而不是单独一个文件；因此如果下载中有某个层已经被其他镜像下载过，则会显示Already exists。下载过程中给出了每一层的ID的前12位，下载结束后给出镜像完整的sha256摘要。")]),t._v(" "),e("p",[t._v("Docker的镜像仓库分为官方仓库和非官方，官方的镜像就是从Docker Hub拉取的；如果想要从第三方的镜像仓库获取，可以在仓库名称前加上仓库的服务地址：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("docker pull <Docker Registry地址:端口号><repository>:<tag>\n")])])]),e("h3",{attrs:{id:"列出镜像"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#列出镜像"}},[t._v("#")]),t._v(" "),e("strong",[t._v("列出镜像")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("[root@localhost dockerfile]# docker image ls\nREPOSITORY            TAG       IMAGE ID       CREATED         SIZE\nfscmdtest             latest    722b57b36507   2 hours ago     231MB\nmycentos              0.2       ef51baa09668   6 hours ago     656MB\ngaoqiaoys/diytomcat   1         bc0c2086cc34   7 days ago      858MB\ndiytomcat             latest    bc0c2086cc34   7 days ago      858MB\nmysql                 5.7       c20987f18b13   14 months ago   448MB\ncentos                7         eeb6ee3f44bd   17 months ago   204MB\ncentos                latest    5d0da3dc9764   17 months ago   231MB\nubuntu                16.04     b6f507652425   17 months ago   135MB\nportainer/portainer   latest    580c0e4e98b0   23 months ago   79.1MB\n")])])]),e("p",[t._v("列表包含了仓库名、标签、镜像ID、创建时间和所占用空间；我们看到有两个centos的镜像，不过两个镜像有不同的标签。")]),t._v(" "),e("p",[t._v("ls命令默认会列出所有的镜像，但是当本地镜像比较多的时候不方便查看，有时候我们希望列出部分的镜像，除了可以通过linux的grep命令，还可以在ls命令后面跟上参数：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("[root@localhost dockerfile]# docker image ls centos\nREPOSITORY   TAG       IMAGE ID       CREATED         SIZE\ncentos       7         eeb6ee3f44bd   17 months ago   204MB\ncentos       latest    5d0da3dc9764   17 months ago   231MB\n")])])]),e("h3",{attrs:{id:"删除镜像"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#删除镜像"}},[t._v("#")]),t._v(" "),e("strong",[t._v("删除镜像")])]),t._v(" "),e("p",[t._v("我们可以通过"),e("strong",[t._v("rm命令")]),t._v("删除本地镜像：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("docker rmi -f 镜像ID 镜像ID 镜像ID 镜像ID #rmi(remove image) 删除指定的镜像\ndocker rmi -f $(docker images -aq) #删除全部镜像\n")])])]),e("p",[t._v("这里的<镜像>，可以是镜像短ID、镜像长ID、镜像名或者镜像摘要；docker image ls列出来的已经是短ID了，我们还可以取前三个字符进行删除；")]),t._v(" "),e("h3",{attrs:{id:"构建镜像"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构建镜像"}},[t._v("#")]),t._v(" "),e("strong",[t._v("构建镜像")])]),t._v(" "),e("p",[t._v("除了使用官方的镜像，我们可以构建自己的镜像；一般都在其他的镜像基础上进行构建，比如node、nginx等；构建镜像需要用到"),e("strong",[t._v("Dockerfile")]),t._v("，它是一个文本文件，文本内容包含了一条条构建镜像所需的指令和说明。")]),t._v(" "),e("p",[t._v("我们在一个空白目录新建一个Dockerfile：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("[root@localhost /]# cd home/\n[root@localhost home]# mkdir mynginx\n[root@localhost home]# cd mynginx\n[root@localhost mynginx]# touch Dockerfile\n")])])]),e("p",[t._v("我们向Dockerfile写入以下内容：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("FROM nginx\nRUN echo '<h1>Hello, This is My Nginx</h1>' > /usr/share/nginx/html/index.html\n")])])]),e("p",[t._v("这里的Dockerfile很简单，就两个命令：FROM和RUN，我们在Dockerfile里面对命令进行详细的介绍；我们使用build命令构建镜像，它的格式为：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("docker build [选项] <上下文路径/URL/->\n")])])]),e("p",[t._v("因此，我们在Dockerfile所在的目录执行命令：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("docker build -t mynginx:v3 .\n")])])]),e("p",[t._v("运行命令:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("[root@localhost mynginx]# docker build -t mynginx:v3 .\nSending build context to Docker daemon  2.048kB\nStep 1/2 : FROM nginx\nlatest: Pulling from library/nginx\na2abf6c4d29d: Pull complete \na9edb18cadd1: Pull complete \n589b7251471a: Pull complete \n186b1aaa4aa6: Pull complete \nb4df32aa5a72: Pull complete \na0bcbecc962e: Pull complete \nDigest: sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31\nStatus: Downloaded newer image for nginx:latest\n ---\x3e 605c77e624dd\nStep 2/2 : RUN echo '<h1>Hello, This is My Nginx</h1>' > /usr/share/nginx/html/index.html\n ---\x3e Running in 7725a7906894\nRemoving intermediate container 7725a7906894\n ---\x3e 2210d8ab747a\nSuccessfully built 2210d8ab747a\nSuccessfully tagged mynginx:v3\n")])])]),e("p",[t._v("构建成功后，我们列出所有的镜像就能看到刚刚构建的mynginx了。在上面的命令中，我们发现最后有一个.，它表示了当前目录，如果不写这个目录会报错提示；如果对应上面的格式，它其实就是上下文路径，那这个上下文路径是做什么用的呢？要理解这个路径的作用，我们首先要来理解Docker的架构。")]),t._v(" "),e("p",[t._v("Docker是一个典型的C/S架构的应用，它可以分为"),e("strong",[t._v("Docker客户端")]),t._v("（平时敲的Docker命令）和"),e("strong",[t._v("Docker服务端")]),t._v("（Docker守护进程）。Docker客户端通过REST API和服务端进行交互，docker客户端每发送一条指令，底层都会转化成REST API调用的形式发送给服务端，服务端处理客户端发送的请求并给出响应。")]),t._v(" "),e("p",[t._v("因此表面上看我们好像在本机上执行各种Docker的功能，实际上都是都是在Docker服务端完成的，包括Docker镜像的构建、容器创建、容器运行等工作都是Docker服务端来完成的，Docker客户端只是承担发送指令的角色。\n"),e("img",{attrs:{src:"https://s1.ax1x.com/2023/02/17/pSbzJbj.png",alt:"docker"}})]),t._v(" "),e("p",[t._v("理解了Docker的架构就很容器理解Docker构建镜像的工作原理了，它的流程大致如下：")]),t._v(" "),e("ol",[e("li",[t._v("执行build命令;")]),t._v(" "),e("li",[t._v("Docker客户端会将构建命令后面指定的上下文路径下的所有文件打包成一个tar包，发送给Docker服务端;")]),t._v(" "),e("li",[t._v("Docker服务端收到客户端发送的tar包，然后解压，根据Dockerfile里面的指令进行镜像的分层构建；")])]),t._v(" "),e("p",[t._v("因此上下文路径本质上就是指定服务端上Dockerfile中指令工作的目录；比如我们在Dockerfile中经常需要拷贝代码到镜像中去，因此会这么写：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("COPY ./package.json /app/\n")])])]),e("p",[t._v("这里要复制的package.json文件，并不一定在docker build命令执行的目录下，也不一定是在Dockerfile文件同级目录下，而是docker build命令指定的上下文路径目录下的package.json。")]),t._v(" "),e("h2",{attrs:{id:"容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容器"}},[t._v("#")]),t._v(" 容器")]),t._v(" "),e("p",[t._v("介绍了镜像，我们到了Docker第三个核心概念了：容器。容器是镜像的运行时的实例，我们可以从一个镜像上启动一个或多个容器。")]),t._v(" "),e("p",[t._v("对容器的管理包括创建、启动、停止、进入、导入导出和删除等，我们分别来看下每个操作的具体命令以及效果。")]),t._v(" "),e("h3",{attrs:{id:"创建启动容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建启动容器"}},[t._v("#")]),t._v(" "),e("strong",[t._v("创建启动容器")])]),t._v(" "),e("p",[t._v("新建并启动一个容器用的命令是"),e("code",[t._v("docker run")]),t._v("，它后面有时候会带上有很长很长的选项，不过其基本的语法如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("docker run [选项] 镜像名称 [命令] [参数...]\n")])])]),e("p",[t._v("它可以带上一些常见的选项：")]),t._v(" "),e("ul",[e("li",[t._v("-d：容器在后台运行")]),t._v(" "),e("li",[t._v("-t：为容器重新分配一个伪输入终端，通常与-i同时使用")]),t._v(" "),e("li",[t._v("-i：以交互模式运行容器，通常与-t同时使用")]),t._v(" "),e("li",[t._v("-P：随机端口映射")]),t._v(" "),e("li",[t._v("-p：指定端口映射")]),t._v(" "),e("li",[t._v("--name：为容器指定一个名称")]),t._v(" "),e("li",[t._v("-e：设置环境变量")]),t._v(" "),e("li",[t._v("--dns：指定容器使用的DNS服务器")]),t._v(" "),e("li",[t._v("-m：设置容器使用内存最大值")]),t._v(" "),e("li",[t._v('--net="bridge": 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；')]),t._v(" "),e("li",[t._v("--link：链接另一个容器")]),t._v(" "),e("li",[t._v("-v：绑定卷")]),t._v(" "),e("li",[t._v("--rm：退出容器后删除该容器"),e("br"),t._v("\n我们创建一个hello world容器：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("docker run hello-world\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("[root@localhost ~]# docker run hello-world\nUnable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\n2db29710123e: Pull complete \nDigest: sha256:2498fce14358aa50ead0cc6c19990fc6ff866ce72aeb5546e1d59caac3d0d60f\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n")])])]),e("p",[t._v("但是这样创建的容器只能看到一堆的打印说明，我们不能对容器进行任何操作，我们可以加上-it选项（-i和-t的简写），来让Docker分配一个终端给这个容器：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("[root@localhost ~]# docker image ls\nREPOSITORY            TAG       IMAGE ID       CREATED         SIZE\nmynginx               v3        2210d8ab747a   22 hours ago    141MB\nfscmdtest             latest    722b57b36507   25 hours ago    231MB\nmycentos              0.2       ef51baa09668   29 hours ago    656MB\ngaoqiaoys/diytomcat   1         bc0c2086cc34   8 days ago      858MB\ndiytomcat             latest    bc0c2086cc34   8 days ago      858MB\nnginx                 latest    605c77e624dd   13 months ago   141MB\nmysql                 5.7       c20987f18b13   14 months ago   448MB\nhello-world           latest    feb5d9fea6a5   17 months ago   13.3kB\ncentos                7         eeb6ee3f44bd   17 months ago   204MB\ncentos                latest    5d0da3dc9764   17 months ago   231MB\nubuntu                16.04     b6f507652425   17 months ago   135MB\nportainer/portainer   latest    580c0e4e98b0   23 months ago   79.1MB\n[root@localhost ~]# docker run -it ubuntu:16.04 /bin/bash\nroot@0bfeadb36d75:/# pwd\n/\nroot@0bfeadb36d75:/# ls\nbin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\nroot@0bfeadb36d75:/# exit\nexit\n")])])]),e("p",[t._v("我们可以在容器内部进行操作了，退出终端可以使用"),e("strong",[t._v("exit")]),t._v("命令或者"),e("strong",[t._v("ctrl+d")]),t._v("；我们退出容器后如果查看运行中的容器，发现并没有任何容器信息。")]),t._v(" "),e("p",[t._v("一般我们都是需要让容器在后台运行，因此我们加上-d：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("[root@localhost ~]# docker run -itd ubuntu:16.04 /bin/bash\n6d837008de8b761c973bd4b60ced42cbc04f39f28e03489a18b93eef8e4755f1\n")])])]),e("p",[t._v("容器不再以命令行的方式呈现了，而是直接丢出一长串的数字字母组合，这是容器的唯一id；再用ps命令查看运行状态的容器，看到我们的容器已经在后台默默运行了：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('[root@localhost ~]# docker ps\nCONTAINER ID   IMAGE                 COMMAND        CREATED          STATUS          PORTS                                       NAMES\n6d837008de8b   ubuntu:16.04          "/bin/bash"    54 seconds ago   Up 53 seconds                                               eloquent_feynman\nd37ca6bc4fa1   portainer/portainer   "/portainer"   2 weeks ago      Up 6 hours      0.0.0.0:8088->9000/tcp, :::8088->9000/tcp   clever_chatterjee\n')])])]),e("p",[t._v("当使用run命令创建容器时，Docker在后台进行了如下的操作：")]),t._v(" "),e("ul",[e("li",[t._v("检查本地是否存在指定的镜像，不存在就从 registry 下载")]),t._v(" "),e("li",[t._v("利用镜像创建并启动一个容器")]),t._v(" "),e("li",[t._v("分配一个文件系统，并在只读的镜像层外面挂载一层可读写层")]),t._v(" "),e("li",[t._v("从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去")]),t._v(" "),e("li",[t._v("从地址池配置一个 ip 地址给容器")]),t._v(" "),e("li",[t._v("执行用户指定的应用程序")]),t._v(" "),e("li",[t._v("执行完毕后容器被终止")])]),t._v(" "),e("h3",{attrs:{id:"终止容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#终止容器"}},[t._v("#")]),t._v(" "),e("strong",[t._v("终止容器")])]),t._v(" "),e("p",[t._v("我们可以使用stop命令来终止容器的运行；如果容器中的应用终结或者报错时，容器也会自动终止；我们可以使用ps命令查看到的容器短id来终止对应的容器：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("[root@localhost ~]# docker stop 6d837008de8b\n")])])]),e("p",[t._v("对于终止状态的容器，ps命令已经不能看到它了，我们可以加上-a选项（表示所有）来查看，它的STATUS已经变成了Exited：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('[root@localhost ~]# docker ps\nCONTAINER ID   IMAGE                 COMMAND        CREATED       STATUS       PORTS                                       NAMES\nd37ca6bc4fa1   portainer/portainer   "/portainer"   2 weeks ago   Up 6 hours   0.0.0.0:8088->9000/tcp, :::8088->9000/tcp   clever_chatterjee\n[root@localhost ~]# docker ps -a\nCONTAINER ID   IMAGE                 COMMAND                  CREATED          STATUS                          PORTS                                                  NAMES\n6d837008de8b   ubuntu:16.04          "/bin/bash"              15 minutes ago   Exited (0) About a minute ago                                                          eloquent_feynman\n0bfeadb36d75   ubuntu:16.04          "/bin/bash"              28 minutes ago   Exited (0) 27 minutes ago                                                              zen_pare\nb5e80ee2512c   hello-world           "/hello"                 31 minutes ago   Exited (0) 31 minutes ago                                                              reverent_northcutt\n8f846e32670f   722b57b36507          "-l"                     26 hours ago     Created                                                                                xenodochial_easley\nd3791da128a8   722b57b36507          "ls -a"                  26 hours ago     Exited (0) 26 hours ago                                                                recursing_bohr\n7153097aa989   mycentos:0.2          "/bin/sh -c /bin/bash"   29 hours ago     Exited (255) 6 hours ago        80/tcp                                                 sad_tharp\nd0df6f6c7ad2   centos                "/bin/bash"              29 hours ago     Exited (127) 29 hours ago                                                              friendly_booth\n3399aab28488   diytomcat             "/bin/sh -c \'/usr/lo…"   8 days ago       Exited (255) 6 hours ago        0.0.0.0:9090->8080/tcp, :::9090->8080/tcp              kuangshentomcat\nb078ab3a2003   mysql:5.7             "docker-entrypoint.s…"   2 weeks ago      Exited (255) 6 hours ago        33060/tcp, 0.0.0.0:3310->3306/tcp, :::3310->3306/tcp   mysql01\nd37ca6bc4fa1   portainer/portainer   "/portainer"             2 weeks ago      Up 6 hours                      0.0.0.0:8088->9000/tcp, :::8088->9000/tcp              clever_chatterjee\n')])])]),e("p",[t._v("终止状态的容器我们可以使用"),e("code",[t._v("docker start [容器id]")]),t._v("来让它重新进入启动状态，运行中的容器我们也可以使用"),e("code",[t._v("docker restart [容器id]")]),t._v("让它重新启动。")]),t._v(" "),e("h3",{attrs:{id:"进入容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进入容器"}},[t._v("#")]),t._v(" "),e("strong",[t._v("进入容器")])]),t._v(" "),e("p",[t._v("有时候我们会需要进入容器进行一些操作，比如进入nginx容器进行平滑重启，我们可以使用"),e("code",[t._v("docker attach")]),t._v("或者"),e("code",[t._v("docker exec")]),t._v("进入，不过推荐使用"),e("code",[t._v("exec")]),t._v("命令。")]),t._v(" "),e("p",[t._v("我们首先看下如果使用attach命令：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("docker start 6d837008de8b\n")])])]),e("p",[t._v("当我们从终端exit后，整个容器会停止；而使用exec命令不会导致容器停止。")]),t._v(" "),e("p",[t._v("如果只使用-i参数，由于没有分配伪终端，界面没有我们熟悉的Linux命令提示符，但是执行命令仍然可以看到运行结果；当使用-i和-t参数时，才能看到我们常见的Linux命令提示符。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ docker exec -i d37ca6bc4fa1 bash\nls\nbin\nboot\ndev\netc\nhome\nlib\npwd\n/\n\n$ docker exec -it d37ca6bc4fa1 bash\nroot@d37ca6bc4fa1:/# exit\n")])])]),e("p",[t._v("需要注意的是，我们进入的容器需要是运行状态，如果不是运行状态，则会报错：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Error response from daemon: Container d37ca6bc4fa1 is not running\n")])])]),e("h3",{attrs:{id:"查看容器日志"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查看容器日志"}},[t._v("#")]),t._v(" "),e("strong",[t._v("查看容器日志")])]),t._v(" "),e("p",[t._v("我们经常需要对容器运行过程进行一些监测，查看它的运行过程记录的日志情况，以及是否报错等等；使用logs命令获取容器的日志。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("docker logs d37ca6bc4fa1\n")])])]),e("p",[t._v("它还支持以下几个参数：")]),t._v(" "),e("ul",[e("li",[t._v("-f : 跟踪日志输出")]),t._v(" "),e("li",[t._v("--since :显示某个开始时间的所有日志")]),t._v(" "),e("li",[t._v("-t : 显示时间戳")]),t._v(" "),e("li",[t._v("--tail :仅列出最新N条容器日志")])]),t._v(" "),e("p",[t._v("logs命令会展示从容器启动以来的所有日志，如果容器运行时间久，会列出非常多的日志，我们可以加tail参数仅展示最新的日志记录：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 列出最新的10条日志\n$ docker logs --tail=10 d37ca6bc4fa1\n")])])])])}),[],!1,null,null,null);e.default=o.exports}}]);